---
title: 对哈希函数的一些认识
date: 2018-11-18 22:15:09
categories: "算法"
tags: ["Hash","算法","概率"]
---

## 哈希函数的定义

>A hash function usually means a function that compresses, meaning the output is shorter than the input. Often, such a function takes an input of arbitrary or almost arbitrary length to one whose length is a fixed number.

一般来说，哈希函数是一个将任意长度（或者近乎任意长度）的输入映射到固定长度的值的函数。

## 哈希函数的应用

制造工具的目的在于使用。哈希函数的出现主要是为了解决这样的问题：

1. 稀疏数据的储存和检索：分布范围大但密度稀疏的数据采用连续储存的方式对空间造成极大的浪费（考虑身份证号的储存为例），采用哈希表技术，利用哈希函数将关键码映射到有限空间进行储存和检索可以解决这类问题。
2. 文件的完整性检查
3. 消息认证
4. 进行安全性检查等

## 哈希函数的特点

1. 哈希函数的输入为任意长度的数据
2. 哈希函数的输出为固定长度的值
3. 哈希函数的计算可以通过硬件或者软件加以实现

从数学的角度来看，哈希函数是一个定义域远大于值域的函数，因此哈希函数一定不是一个单射。多个输入被映射到一个哈希值的情况被称为碰撞（或者冲突）。

## 哈希函数的设计

### 设计的关键

1. 对于散列表来说，碰撞的增加会导致散列表性能的逐步下降，对于安全认证等来说碰撞则意味着不安全，因此哈希函数设计的关键之一在于**尽可能减小冲突**。
2. 显然，当函数将输入**映射到值域中尽可能大的部分**时，冲突的概率也会降低。
3. 不同输入的哈希值**在值域中均匀分布**，有利于减少冲突：若哈希值的分布在值域中有所集中，那么这一部分就很容易出现冲突。但事实上我们总能构造一组输入，使得这一组输入的哈希值集中在值域的某一部分——设计的关键在于，对于构造出的哈希函数，我们构造的（造成冲突的）输入应该尽可能和实际使用中会出现的输入没有交集。
4. 实际使用中，不同自变量变动的部分常常很小，为了达到以上性质，哈希函数应该**对于自变量的变化极其敏感**：自变量任何微小的变化都应该导致哈希值的巨大变化。
5. 而在另一些使用场景中，需要能够快速查找到与某个数据相近的数据，因此希望其哈希值也相近，这样的哈希函数设计与上一条中的刚好相反，例如局部敏感哈希（LSH）。
6. 在一些使用场景中（比如哈希表），要求哈希值的计算应该**尽可能高效**，以保证效率。

### 一些设计技巧

1. 处理器对于**位运算**的计算远比其他类型的计算快，因此很多哈希算法中大量使用了位运算来保证计算效率。

2. Thomas Wang 认为一个好的哈希函数应该容易造成雪崩效应。这里的雪崩效应是从比特位的角度出发的，它指的是，输入值1bit位的变化会造成输出值1/2的bit位发生变化。位运算中的加减、异或、取反和移位等操作都比较容易引起此类变化。

3. 常常需要将哈希值的结果限定在某一特定长度之内，这一工作可以通过取模运算完成。当限定长度为2的幂时，取模操作可以进一步简化为按位与`&`运算：

   ```python
   # length = 2 ** n
   h %= length
   h &= length - 1
   ```

   在length为2的幂时，以上两条语句的计算效果是完全相同的。这也是很多语言中hashmap的长度取为2的幂的原因之一。

4. 关于位运算的一些注意事项：

   1. 任何一个数与另一个数异或两次等于其本身。因此设计函数时尽量避免与重复的部分做异或。
   2. 右移位操作意味的低位数据的丢失，定长整数的左移位操作意味着高位数据的丢失。
   3. Python3中的int是不定长的，需要自己进行截断。

## 哈希函数示例

### Java的HashMap实现中使用的哈希函数

```java
//计算hash值的方法 通过键的hashCode来计算
static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```

函数的输入为对象的hashCode，输出为哈希值，均为32位整数。这个哈希函数用了移位`>>>`和异或`^`操作，将原hash值与其右移20位和12位的结果做异或，然后再向右移位7和4重复一次。这些操作的目的在于尽可能通过哈希函数将输入中可能存在的规律消除（个人想法，欢迎指正）。

### Thomas Wang‘s 32 bit MixFunction

```java
public int hash32shift(int key)
{
  key = ~key + (key << 15); // key = (key << 15) - key - 1;
  key = key ^ (key >>> 12);
  key = key + (key << 2);
  key = key ^ (key >>> 4);
  key = key * 2057; // key = (key + (key << 3)) + (key << 11);
  key = key ^ (key >>> 16);
  return key;
}
```

这一算法进行了更为复杂的变换，以消除输入中可能存在的规律。

值得一提的是这个函数是从32位空间到32位空间的哈希函数，其定义域和值域是相同的——这意味着该函数是可以设计成单射，可以是可逆的，而可逆意味着冲突的消除。以上运算中的常数取得合适时，该函数的确是可逆函数，这也是Thomas的设计初衷：哈希函数负责将输入均匀而可逆的映射到值空间，实际储存空间的限制交给具体的使用者去考虑（比如通过简单的取模操作来进行限制）。

参考文章3中还介绍了64位数映射到32位数的哈希函数以及64位的MixFunction，也是类似的思想，可以参考。

## 哈希函数中的概率问题

### 问题描述

给定问题：设计哈希函数，将64位int的baishiid映射到30bit的空间中，评价该哈希函数的性质是否足够好。给定的样本数据为13180827（约为2的23次幂）个，baishiid已经做过去重。

我们评价哈希函数性质是否足够好的指标为：使用该哈希函数，造成的冲突数量是否已经达到了最优的状况？

具体分析方法如下：

1. 假设我们对于输入中可能存在的规律并不了解，因而不能以此作为依据设计性能更加良好的哈希函数。这种情况下，能做到的最好的哈希函数，我们期望其输出总是均匀分布在值域（2的30次方）中。
2. 把值空间看做2的30次方个桶。假设已经找到了该最优哈希函数，那么对于我们给定的输入，每个哈希值落在每个桶中的概率是相同的。
3. 于是该问题变成：**在2的30次方个桶中放置13180827个球，每个球出现在每个桶中的概率均等，每个桶可以放置的球没有上限，每个球出现在每个桶中的概率彼此独立，求桶中多出的球的数目（即冲突次数）的期望？**

进一步把问题一般化，在N个桶中放置M(M<=N)个球，每个球出现在每个桶中的概率均等，每个桶可以放置的球没有上限，每个球出现在每个桶中的概率彼此独立，求桶中多出的球的数目（即冲突次数）的期望？

在求解上面问题之前，先看一些其他问题的概率。

### 每个桶只放一个球的概率

即不会出现哈希碰撞的概率。

放置第一个球时，一定不会冲突，概率为$\frac{N}{N}$，放置第二个球时，不冲突的概率为$\frac{N-1}{N}$；以此类推，可得放完所有求都未发生冲突的概率：
$$
P(未发生冲突的概率)=\frac{N}{N}\times\frac{N-1}{N}\times\frac{N-2}{N}\times\cdots\times\frac{N-(M-1)}{N}
$$
这个概率的计算很难完成，我们需要对其进行简化。利用$y=e^{-x}$的泰勒展开式:
$$
e^{-x}=1-x+\frac{1}{2!}x^2-\frac{1}{3!}x^3+\frac{1}{4!}x^4-\cdots\cdots
$$
当x很小时，有$1-x=e^{-x}$，因此有
$$
P(未发生冲突的概率)=e^{-\frac{1}{N}-\frac{2}{N}-\cdots-\frac{M-1}{N}}=e^{-\frac{M(M-1)}{2N}}
$$
到这里我们得到了哈希函数出现冲突概率的公式，将$M=13180827\quad N=2^{30}$代入，可求得，这个值几乎等于1。也就是说，**在题目给定的条件下，试图设计一个完全无冲突的哈希函数是不现实的**。

### 空桶的期望

即值域中未被利用的空间的期望。

我们以第一个桶为例，第一次放置球时该桶未被放置的概率为$1-\frac{1}{N}$，到最后一次（M次）放置完毕后都没有放入球的概率为$(1-\frac{1}{N})^M$；桶的个数为N，因此空桶的期望为（空桶个数是个二项分布）：
$$
E(空桶个数)=N(1-\frac{1}{N})^M=N(1-\frac{1}{N})^{-N(-\frac{M}{N})}=Ne^{-\frac{M}{N}}
$$
这里利用
$$
\lim_{x\to-\infty} (1+\frac{1}{x})^{x}=e
$$
进行了简化。当N很大时计算结果的误差很小。

将$M=13180827\quad N=2^{30}$代入后可得，**空桶的期望为1060641568**。

计算这个期望的意义，一是接下来计算冲突次数的期望会用到，二是在于顺便计算出了**添加新的项时出现冲突的概率**：
$$
E(添加新的项出现冲突的概率)=1-(1-\frac{1}{N})^M=1-e^{-\frac M N}=1-e^{-f}
$$
式中$f$为装填因子：
$$
\text{load factor:}\quad f=\frac M N
$$
由此可见，在向哈希表中加入新的项时，出现冲突的概率只和装填因子有关。java的hashmap实现中，默认的最大装填因子为0.75，当$f=0.75$时这个概率为0.5276，这保证了在hashmap中添加新项时出现冲突的概率不超过0.5276。（对为什么这个取值是0.75感兴趣的话可以参考这篇文章：[为什么 java Hashmap 中的加载因子是默认为0.75](https://www.jianshu.com/p/dff8f4641814)）

### 冲突次数期望

每个baishiid都不同，因此只要一个id被hash到已经用过的桶中就是一次冲突，因此冲突次数=M-被占用的桶数。而被占用的桶数又等于桶的总数减去空桶数目，因此可知：
$$
E(冲突次数)=M-(N-Ne^{-\frac{M}{N}})
$$
代入后计算得到，冲突次数的期望为80571。

### 每个桶至少有一个球时球的总数的期望

即100%出现冲突时，已被哈希的输入的期望：当M为多少时，每个桶中至少有一个球？

用$X_i$表示从第一次占用$i-1$个桶到第一次占用$i$个桶之间放入的球的个数。$X_1$表示从所有桶都为空到第一次占用一个桶时放入球的总数，显然$X_1=1$；在已经占用$i-1$个桶的情况下，每次放球放进新桶的概率为$p=\frac{N-(i-1)}{N}$，因此$X_i$的期望为：
$$
E(X_i)=\frac{1}{p}=\frac{N}{N-i+1}
$$
每个桶都填满需要放入的球数记为$X$，则有
$$
X=X_1+X_2+\cdots+X_N
$$
于是有
$$
\begin{align}
E(X)&=\sum_{j=1}^{N}E(X_j)=\sum_{j=1}^{N}\frac{N}{N-j+1}\\
&=N\sum_{j=1}^{N}\frac{1}{N-j+1}\\
&=N\sum_{i=1}^{N}\frac{1}{i}\\
\end{align}
$$
后面和求和项为调和级数：
$$
\sum_{i=1}^{N}\frac{1}{i}=\ln N+C+\varepsilon_n
$$
其中$C=0.557 215\cdots$为欧拉常数。因此有
$$
E(X)=O(N\ln N)
$$
由此可见，如果我们在所有桶都满的时候才对hashmap进行扩容，扩容时的数据量的期望在$N\ln N$这个量级。

### 试验验证

对于题目给出的13180827数据，用以下几个哈希函数做了试验，并统计了冲突次数。测试代码如下：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys


def TW6432_hash(val):
    val = (~val) + (val << 18)
    val = val ^ (val >> 31)
    val = val * 21
    val = val ^ (val >> 11)
    val = val + (val << 6)
    val = val ^ (val >> 22)
    return val & 0x3FFFFFFF


def java_hash(val):
    val ^= val >> 32
    val ^= (val >> 20) ^ (val >> 12)
    val ^= (val >> 7) ^ (val >> 4)
    return val & 0x3FFFFFFF


def TW64shift(val):
    val = (~val) + (val << 21)
    val = val ^ (val >> 24)
    val = (val + (val << 3)) + (val << 8)
    val = val ^ (val >> 14)
    val = (val + (val << 2)) + (val << 4)
    val = val ^ (val >> 28)
    val = val + (val << 31)
    return val & 0x3FFFFFFF


def test_hash(hash_func, infile):
    of_name = 'result_' + hash_func.__name__
    results = set()
    with open(infile, 'r') as i_f, open(of_name, 'w') as o_f:
        for line in i_f:
            line = line.rstrip('\n')
            long = int(line)
            hash_ = hash_func(long)
            results.add(hash_)
            o_f.write(str(hash_)+'\n')
    print hash_func.__name__ + ': {}'.format(len(results))

if __name__ == '__main__':
    file = sys.argv[1]
    test_hash(TW6432_hash, file)
    test_hash(java_hash, file)
    test_hash(TW64shift, file)
    exit(0)
```

试验结果如下：

| 哈希函数      | 冲突次数     |
| ------------- | ------------ |
| 最优情况      | $E(X)=80571$ |
| 64to32mix     | 79940        |
| java_hash     | 81093        |
| Thomas64shift | 80858        |

可见Thomas Wang's 64 bit to 32 bit Hash Functions 效果已经很好了。

## 需要注意的问题

1. 如果我们能够知道自变量中存在的规律（模式），那么就有可能设计出更加高效的哈希函数。以上讨论均基于自变量的具体分布未知的情况下最优的结果。

   考虑以下情况：

   已知自变量为10位十进制数，**后两位均为0**，要求将其映射到6位十进制数，那么显然可以除以100之后再去做哈希，相比于未知自变量的分布模式时只能考虑输入为任意10位十进制数的情况，储存空间的利用率可以更高。

2. 在未知自变量分布模式的情况下，为了获得良好的性能，我们期望哈希函数能够在不同的自变量分布情况下，都将其均匀地映射到值域空间中。

## 扩展：完美哈希

待续

## 参考文章

1. <http://web.archive.org/web/20071223173210/http://www.concentric.net/~Ttwang/tech/inthash.htm>
2. <http://www.cnblogs.com/fengfenggirl/p/hash_prob.html>
3. <https://gist.github.com/badboy/6267743>
4. <https://blog.csdn.net/jasper_xulei/article/details/18364313>
5. <https://www.cnblogs.com/wt869054461/p/8148940.html>



